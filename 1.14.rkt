;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-beginner-reader.ss" "lang")((modname |1.14|) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
; Упражнение 1.14.
; Нарисуйте дерево, иллюстрирующее процесс,
; который порождается процедурой count-change из раздела 1.2.2 при размене 11 центов.
; Каковы порядки роста памяти и числа шагов,
; используемых этим процессом при увеличении суммы, которую требуется разменять?

(define (count-change amount)
  (count amount 5))

; Число способов разменять сумму amount с помощью kind-of-coins типов монет равняется
; * числу способов разменять сумму amount с помощью всех типов монет, кроме первого,
;   плюс
; * число способов разменять сумму (amount - first-denomination) с использованием всех kind-of-coins типов монет,
;   где first-denomination — достоинство монет первого типа.
(define (count amount kind-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kind-of-coins 0)) 0)
        (else (+ (count amount (- kind-of-coins 1))
                 (count (- amount (first-denomination kind-of-coins)) kind-of-coins)))))

(define (first-denomination kind-of-coins)
  (cond ((= kind-of-coins 1) 1)
        ((= kind-of-coins 2) 5)
        ((= kind-of-coins 3) 10)
        ((= kind-of-coins 4) 25)
        ((= kind-of-coins 5) 50)))

(count-change 11)

; При вызове процедурыв памяти требуется объём,
; пропорциональный глубине соответствующего параметрам вызова узла дерева.
; Так как максимальная высота дерева растет линейно с ростом суммы, которую требуется разменять,
; порядок роста памяти также линеен Θ(n).

; Пусть каждый узел в дереве выполняет одну операцию.
; Для amount n и kind-of-coins 5, кол-во операций, выполняемых процедурой равно
; 1 +
; + число операций, выполняемых поддеревом (count-change n 4) +
; + число операций, выполняемых поддеревом (count-change (- n 50) 5).

; Пусть N(n; m) -- кол-во операций выполняемых поддеревом (count-change n m).
; Тогда, имеем:
; N(n; 5) = 1 + N(n; 4) + N(n - 50; 5)
; N(n; 4) = 1 + N(n; 3) + N(n - 25; 4)
; N(n; 3) = 1 + N(n; 2) + N(n - 10; 3)
; N(n; 2) = 1 + N(n; 1) + N(n -  5; 2)
; N(n; 1) = 1 + N(n; 0) + N(n -  1; 1)

; (count-change n 0) выполняет только одну операцию (возвращает 0), значит:
; N(n; 0) = 1
; N(n; 1) = 1 + 1 + N(n - 1; 1)
;
; Рассмотрим N(n - 1; 1):
; N(n - 1; 1) = 1 + N(n - 1; 0) + N(n - 2; 1)
;
; (count-change (- n 1) 0) выполняет только одну операцию (возвращает 0).
; Этот процесс продолжается до тех пор, пока аргумент argument не будет равен (- n n):
; N(n - n; 1) = 1.
;
; *подсчёт кол-ва операций*
; N(n - (n-1); 1) = 1 + N(n - (n-1); 0) + N(n - (n-2); 0) =
;                 = 1 + N(        1; 0) + N(        2; 0) =
;                 = 1 + 1               + 1               =
;                 = 3
;
; N(n - (n-2); 1) = 1 + 1 + N(n - (n-1); 1) = 1 + 1 + 3 = 5
; N(n - (n-3); 1) = 1 + 1 + N(n - (n-2); 1) = 1 + 1 + 5 = 7
; N(n - (n-4); 1) = 1 + 1 + N(n - (n-3); 1) = 1 + 1 + 7 = 9
;
; Очевидно, что процесс продолжается до (count-change n 1):
; N(n; 1) = 1 + 1 + N(n - 1; 1) = 2n + 1

; Древовидно-рекурсивные процессы требуют выполнения цепочки операций, пропорциональных количеству узлов в дереве,
; поэтому нам нужно посчитать оставшееся количество операций.

; N(    n; 2) = 1 + N(    n; 1) + N(    n -  5; 2)
;
; N(n - 5; 2) = 1 + N(n - 5; 1) + N(n - 5 -  5; 2) =
;             = 1 + N(n - 5; 1) + N(    n - 10; 2)
;
; Этот процесс продолжается до тех пор, пока n не станет <= 0, или примерно n/5 раз,
; поскольку каждое расширение 2-го члена вычитает 5 из его аргумента количества.
;
; Каждой такой процесс производит N (a 1) членов,
; где a -- сумма, и каждый из этих членов производит 2a + 1 операций.
;
; Вычитание константы из n на каждом шаге не меняет того факта,
; что каждый шаг является линейным (порядок n) процессом,
; поэтому мы можем игнорировать вычитание при расчете порядка роста.
;
; n * n/5 шагов = n^2/5 шагов
; Этот термин превосходит 2n + 1 шаг, который мы вычислили для предыдущей ветви, поэтому мы можем теперь игнорировать 2n + 1 член и сказать, что вычисление (cc n 2) имеет порядок n^2 / 5 шагов.
;
; Аналогично для монет остальных достоинств.
; Опустим константы и получим Θ(n^5).